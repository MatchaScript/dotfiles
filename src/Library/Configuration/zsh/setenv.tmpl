#!/usr/bin/env zsh

# setenv.sh - Load systemd-style environment.d files for macOS using launchctl
#
# This script reads environment variable files from ~/Library/Configuration/environment.d/
# and sets them using launchctl setenv for macOS system-wide environment variables.
# 
# File format: VAR="VALUE" or VAR=VALUE (systemd environment.d format)

set -uo pipefail

# Enable extended glob patterns for zsh
setopt extended_glob

# Default environment.d directory
ENV_DIR="${HOME}/Library/Configuration/environment.d"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1" >&2
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1" >&2
}

# Function to process a single environment file
process_env_file() {
    local file="$1"
    local filename="$(basename "$file")"
    
    log_info "Processing $filename..."
    
    # Skip if file doesn't exist or is not readable
    if [[ ! -r "$file" ]]; then
        log_warn "Cannot read file: $file"
        return 1
    fi
    
    local line_count=0
    local set_count=0
    
    # Read file line by line (zsh compatible)
    while IFS= read -r line; do
        ((line_count++))
        
        # Debug: show the line being processed
        [[ -n "${DEBUG:-}" ]] && log_info "Line $line_count: $line"
        
        # Skip empty lines and comments
        if [[ -z "$line" || "$line" =~ '^[[:space:]]*#' ]]; then
            continue
        fi
        
        # Parse VAR="VALUE" or VAR=VALUE format using parameter expansion
        if [[ "$line" =~ '^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)=' ]]; then
            # Extract variable name and value using zsh's built-in parameter expansion
            local temp_line="${line#"${line%%[![:space:]]*}"}" # remove leading whitespace
            local var_name="${temp_line%%=*}"
            local var_value="${temp_line#*=}"
            
            # Debug: show extracted values
            [[ -n "${DEBUG:-}" ]] && log_info "Extracted: $var_name = '$var_value'"
            
            # Remove quotes if present
            if [[ "$var_value" =~ '^".*"$' ]]; then
                var_value="${var_value#\"}"
                var_value="${var_value%\"}"
            elif [[ "$var_value" =~ "^'.*'$" ]]; then
                var_value="${var_value#\'}"
                var_value="${var_value%\'}"
            fi
            
            # Expand variables in the value (handle complex shell expansion)
            # Use safer variable expansion for systemd-style defaults
            if [[ "$var_value" =~ '\$\{[^}]+:-[^}]+\}' ]]; then
                # Handle ${VAR:-default} syntax
                var_value=$(eval "echo \"$var_value\"" 2>/dev/null || echo "$var_value")
            elif [[ "$var_value" =~ '\$[A-Za-z_][A-Za-z0-9_]*' ]]; then
                # Handle simple $VAR expansion
                var_value=$(eval "echo \"$var_value\"" 2>/dev/null || echo "$var_value")
            fi
            
            # Debug: show final value
            [[ -n "${DEBUG:-}" ]] && log_info "Final value: '$var_value'"
            
            # Set environment variable using launchctl
            if launchctl setenv "$var_name" "$var_value" 2>/dev/null; then
                log_success "Set $var_name=\"$var_value\""
                ((set_count++))
            else
                log_error "Failed to set $var_name=\"$var_value\""
            fi
        else
            log_warn "Invalid line format in $filename:$line_count: $line"
        fi
    done < "$file"
    
    log_info "Processed $filename: $set_count variables set from $line_count lines"
    return 0
}

# Function to process all environment files recursively
process_env_directory() {
    local env_dir="$1"
    
    if [[ ! -d "$env_dir" ]]; then
        log_error "Environment directory does not exist: $env_dir"
        return 1
    fi
    
    log_info "Processing environment files from: $env_dir"
    
    local total_files=0
    local processed_files=0
    
    # Find all .conf files recursively and sort them
    local files=()
    while IFS= read -r -d '' file; do
        files+=("$file")
    done < <(find "$env_dir" -name "*.conf" -type f -print0 | sort -z)
    
    [[ -n "${DEBUG:-}" ]] && log_info "Found ${#files[@]} files to process"
    
    if [[ ${#files[@]} -eq 0 ]]; then
        log_warn "No environment files (*.conf) found in $env_dir"
        return 1
    fi
    
    for file in "${files[@]}"; do
        ((total_files++))
        [[ -n "${DEBUG:-}" ]] && log_info "Processing file: $file"
        
        # Process file and continue even if it fails
        if process_env_file "$file" 2>/dev/null; then
            ((processed_files++))
        else
            log_warn "Failed to process $file completely"
        fi
    done
    
    log_info "Summary: $processed_files/$total_files files processed successfully"
    
    if [[ $processed_files -eq 0 ]]; then
        log_warn "No environment files were processed successfully"
        return 1
    fi
    
    return 0
}

# Function to show current environment variables
show_current_env() {
    log_info "Current launchctl environment variables:"
    launchctl getenv PATH 2>/dev/null && echo "PATH=$(launchctl getenv PATH)" || true
    
    # Show some common variables if they exist
    for var in XDG_CONFIG_HOME XDG_DATA_HOME XDG_CACHE_HOME GOPATH; do
        local value
        if value=$(launchctl getenv "$var" 2>/dev/null); then
            echo "$var=$value"
        fi
    done
}

# Function to unset all environment variables (cleanup)
cleanup_env() {
    local env_dir="$1"
    
    log_info "Cleaning up environment variables..."
    
    if [[ ! -d "$env_dir" ]]; then
        log_error "Environment directory does not exist: $env_dir"
        return 1
    fi
    
    local unset_count=0
    
    # Find all .conf files and extract variable names
    while IFS= read -r -d '' file; do
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip empty lines and comments
            if [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]]; then
                continue
            fi
            
            # Parse VAR="VALUE" or VAR=VALUE format
            if [[ "$line" =~ ^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
                local var_name="${BASH_REMATCH[1]}"
                
                if launchctl unsetenv "$var_name" 2>/dev/null; then
                    log_success "Unset $var_name"
                    ((unset_count++))
                fi
            fi
        done < "$file"
    done < <(find "$env_dir" -name "*.conf" -type f -print0)
    
    log_info "Cleanup complete: $unset_count variables unset"
}

# Main function
main() {
    local command="${1:-load}"
    
    case "$command" in
        debug)
            DEBUG=1
            log_info "Debug mode enabled"
            process_env_directory "$ENV_DIR"
            ;;
        load|set)
            process_env_directory "$ENV_DIR"
            ;;
        show|list)
            show_current_env
            ;;
        clean|cleanup|unset)
            cleanup_env "$ENV_DIR"
            ;;
        help|--help|-h)
            cat << EOF
Usage: $0 [COMMAND]

Commands:
    load, set     Load environment variables from .conf files (default)
    show, list    Show current launchctl environment variables
    clean, unset  Remove environment variables defined in .conf files
    debug         Run in debug mode with verbose output
    help          Show this help message

Environment files are read from: $ENV_DIR

File format (systemd environment.d style):
    VAR="value"
    VAR=value
    # Comments are ignored
    
Examples:
    $0              # Load all environment variables
    $0 debug        # Load with debug output
    $0 show         # Show current variables
    $0 clean        # Remove all variables
EOF
            ;;
        *)
            log_error "Unknown command: $command"
            log_info "Use '$0 help' for usage information"
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"